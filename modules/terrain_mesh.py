"""
terrain_mesh.py
---------------
Converts a .npy heightmap (generated by fbm.py) into a 3D mesh (.obj) with optional
micro-displacement for fine surface detail.

Purpose in Pipeline:
    - Step 4 in `main.py`: transforms heightmap data into geometry for Isaac Sim.
    - Produces an .obj file for later conversion to USD.
    - Adds high-frequency surface details (micro-displacement) from a grayscale texture.

Workflow:
    1. Load heightmap (.npy) and convert to vertex/face data.
    2. Export terrain as a Wavefront OBJ file.
    3. Optionally tile a grayscale displacement texture (bump map).
    4. Apply micro-displacement to vertices for fine detail (e.g., rocks, ground roughness).
    5. Optionally apply displacement from PNG images (e.g., roads).

Inputs:
    - physical_size_m: physical width of terrain (meters).
    - hill_path_npy: path to heightmap (.npy).
    - obj_output_path: output path for generated OBJ mesh.
    - macro_z_scale: vertical scale multiplier for macro heightmap.
    - bump_path_npy: grayscale texture used for micro-displacement.
    - micro_z_scale: vertical scale multiplier for micro displacement.
    - road_path: optional grayscale PNG for road elevation.
    - road_z_scale: vertical scale multiplier for road displacement.

Outputs:
    - .obj file containing full terrain mesh.

Dependencies:
    - numpy
    - OpenCV (cv2)
    - Pillow (PIL)
    - Called by `main.py` → `TerrainMeshGenerator.process()`

Example:
    mesh = TerrainMeshGenerator(
        physical_size_m=500,
        hill_path_npy="output/heightmap.npy",
        obj_output_path="output/terrain.obj",
        macro_z_scale=1.0,
        bump_path_npy="assets/textures/displacement.jpg",
        micro_z_scale=0.05,
        road_path="output/roadMap.png"
    )
    mesh.process()
"""

import numpy as np
import cv2
import os
from PIL import Image


class TerrainMeshGenerator:
    """
    Converts heightmaps into OBJ meshes with optional fine displacement.
    """

    def __init__(
        self,
        physical_size_m,
        hill_path_npy,
        obj_output_path,
        macro_z_scale,
        bump_path_npy,
        micro_z_scale,
        road_path,
        road_z_scale=0,
    ):
        self.physical_size = physical_size_m
        self.hill_path = hill_path_npy
        self.obj_output_path = obj_output_path
        self.macro_z_scale = macro_z_scale
        self.bump_path = bump_path_npy
        self.micro_z_scale = micro_z_scale
        self.road_path = road_path
        self.road_z_scale = road_z_scale

    def process(self):
        """
        Main pipeline for terrain mesh creation:
            1. Generate macro mesh from heightmap.
            2. Tile displacement texture.
            3. Apply micro displacement to vertices.
        """
        self.generate_obj_from_heightmap(
            self.hill_path, self.obj_output_path, self.macro_z_scale
        )
        self.dirt = self.tile_texture(
            self.bump_path, (2048, 2048), self.physical_size / 2
        )
        self.apply_micro_displacement(
            self.obj_output_path, self.obj_output_path, self.dirt, self.micro_z_scale
        )
        # Optional: apply displacement from road map PNG
        # self.apply_micro_displacement_png(self.obj_output_path, self.obj_output_path, self.road_path, self.road_z_scale)

    def generate_obj_from_heightmap(self, hill_path, obj_output_path, z_scale=1.0):
        """
        Converts heightmap to OBJ format.
        """
        height_data = np.load(hill_path)
        rows, cols = height_data.shape

        # World space spacing between vertices
        spacing_x = self.physical_size / (cols - 1)
        spacing_y = self.physical_size / (rows - 1)

        # Vertex positions
        vertices = [
            (x * spacing_x, y * spacing_y, height_data[y, x] * z_scale)
            for y in range(rows)
            for x in range(cols)
        ]

        # Index mapping for faces
        def idx(x, y):
            return y * cols + x + 1

        # Triangulate mesh (two triangles per grid square)
        faces = [
            (idx(x, y), idx(x + 1, y), idx(x, y + 1))
            for y in range(rows - 1)
            for x in range(cols - 1)
        ]
        faces += [
            (idx(x + 1, y), idx(x + 1, y + 1), idx(x, y + 1))
            for y in range(rows - 1)
            for x in range(cols - 1)
        ]

        # Save OBJ file
        with open(obj_output_path, "w") as f:
            for v in vertices:
                f.write(f"v {v[0]:.4f} {v[1]:.4f} {v[2]:.4f}\n")
            for face in faces:
                f.write(f"f {face[0]} {face[1]} {face[2]}\n")

        print(f"[✓] Mesh saved to {obj_output_path}")

    def tile_texture(self, texture, target_shape, tile_multiplier=1.0):
        """
        Loads a grayscale texture and tiles it to match the target size.
        """
        img = cv2.imread(texture, cv2.IMREAD_GRAYSCALE) / 255.0
        resized = cv2.resize(
            img,
            (int(img.shape[1] / tile_multiplier), int(img.shape[0] / tile_multiplier)),
        )
        reps = (
            int(np.ceil(target_shape[0] / resized.shape[0])),
            int(np.ceil(target_shape[1] / resized.shape[1])),
        )
        tiled = np.tile(resized, reps)
        return tiled[: target_shape[0], : target_shape[1]]

    def apply_micro_displacement(self, obj_path, output_path, heightmap, scale):
        """
        Modifies existing OBJ vertices based on grayscale heightmap values.
        """
        h, w = heightmap.shape
        px = self.physical_size / (w - 1)
        py = self.physical_size / (h - 1)

        with open(obj_path, "r") as f:
            lines = f.readlines()

        new_lines = []
        for line in lines:
            if line.startswith("v "):
                x, y, z = map(float, line.strip().split()[1:])
                u = min(int(x / px), w - 1)
                v = min(int(y / py), h - 1)
                z += heightmap[v, u] * scale
                new_lines.append(f"v {x:.4f} {y:.4f} {z:.4f}\n")
            else:
                new_lines.append(line)

        with open(output_path, "w") as f:
            f.writelines(new_lines)

    def apply_micro_displacement_png(self, obj_path, output_path, img_path, scale):
        """
        Applies displacement from a grayscale PNG image (e.g., road elevation).
        """
        img = Image.open(img_path).convert("L")
        heightmap = np.array(img).astype(np.float32) / 255.0
        self.apply_micro_displacement(obj_path, output_path, heightmap, scale)
